#region VEXcode Generated Robot Configuration
from vex import *
import urandom

# Brain should be defined by default
brain=Brain()

# Robot configuration code
controller_1 = Controller(PRIMARY)
FrontLeft = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)
FrontRight = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)
optical = Optical(Ports.PORT11)
Conveyor = Motor(Ports.PORT5, GearSetting.RATIO_36_1, True)
StringMotor = Motor(Ports.PORT15, GearSetting.RATIO_6_1, False)
LeftFlywheel = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)
RightFlywheel = Motor(Ports.PORT7, GearSetting.RATIO_18_1, True)
string = DigitalOut(brain.three_wire_port.a)
BackLeft = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)
BackRight = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)


# wait for rotation sensor to fully initialize
wait(30, MSEC)
#endregion VEXcode Generated Robot Configuration

# ------------------------------------------
# 
# 	Project: Competition
#	Authors: Steven Canton and Karter Crites
#	Created: Sep 30, 2022
# 
# ------------------------------------------

# Begin project code

#Motor things
Flywheel = MotorGroup(LeftFlywheel, RightFlywheel)
Left = MotorGroup(FrontLeft, BackLeft)
Right = MotorGroup(FrontRight, BackRight)

#Print port setings so that team can seamlessly know where each motor is connected
brain.screen.print("Front Left Wheel: 1 Back: 3")
brain.screen.next_row()
brain.screen.print("Front Right Wheel: 2 Back: 4")
brain.screen.next_row()
brain.screen.print("Conveyor System: 5")
brain.screen.next_row()
brain.screen.print("Left Flywheel: 6")
brain.screen.next_row()
brain.screen.print("Right Flywheel: 7")
brain.screen.next_row()
brain.screen.print("Optical: 11")
brain.screen.next_row()
brain.screen.print("The string launchers: A")
brain.screen.next_row()
brain.screen.print("The string motors: 15")

#Set velocities
Left.set_velocity(100,PERCENT)
Right.set_velocity(100,PERCENT)
Flywheel.set_velocity(100,PERCENT)
Conveyor.set_velocity(100,PERCENT)
StringMotor.set_velocity(25,PERCENT)
Conveyor.set_max_torque(100,PERCENT)

#Variables
FlywheelSpeed = 12.0
intakeIn = False
intakeOut = False

#Setting motors to their respective stopping positions
Left.set_stopping(BRAKE)
Right.set_stopping(BRAKE)
Flywheel.set_stopping(BRAKE)
Conveyor.set_stopping(BRAKE)
StringMotor.set_stopping(BRAKE)

#Function for controller printing
def printing(num):
    controller_1.screen.clear_screen()
    controller_1.screen.set_cursor(1,1)
    controller_1.screen.print("Flywheel speed: ")
    controller_1.screen.set_cursor(1,16)
    controller_1.screen.print(num)



def pre_autonomous():
    #Functions For Controller Inputs:
    #Robot Movement (Axis 2 and 3)
    def Axis3Changed():
        Left.spin(FORWARD, controller_1.axis3.position(), VOLT)

    def Axis2Changed():
        Right.spin(FORWARD, controller_1.axis2.position(), VOLT)

    #Conveyor (Button B)
    def ButtonBPressed():
        Conveyor.spin(FORWARD)
    def ButtonBReleased():
        Conveyor.stop()
    #Flywheel (Button A)
    def ButtonAPressed():
        Flywheel.spin(FORWARD, FlywheelSpeed, VOLT)

    def ButtonAReleased():
        Flywheel.stop()

    #Changing the Speed of the Flywheel (L2 and R2) and making the flwheel go as well
    def LeftB2():
        global FlywheelSpeed
        if FlywheelSpeed < 12.0:
            FlywheelSpeed += 1.0
        Flywheel.spin(FORWARD, FlywheelSpeed, VOLT)
        printing(FlywheelSpeed)

    def LeftB2R():
        Flywheel.stop()

    def RightB2():
        global FlywheelSpeed
        if FlywheelSpeed > 0:
            FlywheelSpeed -= 1.0
        Flywheel.spin(FORWARD, FlywheelSpeed, VOLT)
        printing(FlywheelSpeed)

    def RightB2R():
        Flywheel.stop()

    #Endgame string launching
    def LeftB1P():
        Conveyor.spin(REVERSE)

    def LeftB1R():
        # if intakeOut == False:
        #     intakeOut = True
        # elif intakeOut == True:
        #     intakeOut = False
        Conveyor.stop()

    def RightB1P():    
        Conveyor.spin(FORWARD)

    def RightB1R():
        # if intakeIn == False:
        #     intakeIn = True
        # elif intakeIn == True:
        #     intakeIn = False
        Conveyor.stop()

    def ButtonDownPressed():
        StringMotor.spin(REVERSE)

    def ButtonDownReleased():
        StringMotor.stop()

    def ButtonUpPressed():
        StringMotor.spin(FORWARD)

    def ButtonUpReleased():
        StringMotor.stop()
    # system event handlers
    controller_1.axis3.changed(Axis3Changed)
    controller_1.axis2.changed(Axis2Changed)
    controller_1.buttonB.pressed(ButtonBPressed)
    controller_1.buttonA.pressed(ButtonAPressed)
    controller_1.buttonB.released(ButtonBReleased)
    controller_1.buttonA.released(ButtonAReleased)
    controller_1.buttonL2.pressed(LeftB2)
    controller_1.buttonR2.pressed(RightB2)
    controller_1.buttonL2.released(LeftB2R)
    controller_1.buttonR2.released(RightB2R)
    controller_1.buttonL1.pressed(LeftB1P)
    controller_1.buttonL1.released(LeftB1R)
    controller_1.buttonR1.pressed(RightB1P)
    controller_1.buttonR1.released(RightB1R)
    controller_1.buttonDown.pressed(ButtonDownPressed)
    controller_1.buttonDown.released(ButtonDownReleased)
    controller_1.buttonUp.pressed(ButtonUpPressed)
    controller_1.buttonUp.released(ButtonUpReleased)
    controller_1.buttonX.released(autonomous)

    # add 15ms delay to make sure events are registered correctly.
    wait(15, MSEC)

def autonomous():
    '''

    THIS IS A MANUAL, PLEASE READ BEFORE PROGRAMMING AUTONOMOUS
    Use MoveForward() MoveBack() TurnLeft() and TurnRight() to move the robot easier. 
    Inside the parentheses input the amount of time (in seconds) you want the robot 
    to move or turn in the respective direction. You also need to put in the amount of
    volts that will go to the motors when the function is called. 

    For MoveForward() there is a parameter that allows you to use the conveyor whilst you move.
    Input either True or False into this area to say if the conveyor should move.

    There is also ConveyorSpin() and FlywheelSpin() which ConveyorSpin() only has time as a 
    parameter, whilst FlywheelSPin has both the time and the volts.

    There is also OpticalChecker(), which is the roller spinner. I could defo change the name.
    It has no parameters but is currently not able to use

    Also, StringStart() and StringEnd() have no parameters and dont have any wait functions,
    so you can make it drop the string while moving the robot. 

    ShootDisk() moves all of the conveyor motors as well as the Flywheels, its used as a general
    function when you want to have the disks to shoot.
    It only uses one parameter, which is the amount of time you want the motors to move.

    RotateForward() and RotateReverse() are functions that take in a number and a list for the
    all of the motors you want to rotate in the respective direction of the function.
    The number that you input is the amount of seconds you want those motors to rotate.

    Zero volts does nothing and 12 volts go the fastest that the motor can move

    The fuctions should be like this:

    MoveForward([the amount of seconds you want], [volts from 0 - 12], [If you would like]
                                                                [the cnoveyor to go while moving]) 
    MoveBack([seconds], [volts]) 
    TurnLeft([seconds], [volts])
    TurnRight([seconds], [volts])
    ConveyorSpin([seconds], [volts], [direction])
    FlywheelSpin([seconds], [volts])
    OpticalChecker()
    StringStart()
    StringEnd()
    ShootDisk([seconds])
    RotateForward([seconds], [list of motors])
    RotateReverse([seconds], [list of motors])

    Note that autonomous is only 15 seconds, so be mindfull of how much time you spend using the functions
    '''

    # This autonomous is set so its able to get to the roller from the get go (2 preloads)
    # Mostly Finished!
    def FromRoller():
        # RightFlywheel.spin(FORWARD)
        # LeftFlywheel.spin(FORWARD)
        #270 degree rotation
        MoveForward(.39, 12, True)
        wait(.3,SECONDS)
        # Rolling Motor
        MoveBack(.6, 7)
        wait(.3,SECONDS)
        # Move Back Slightly
        TurnLeft(2.4,6)
        wait(.3,SECONDS)
        # Turn towards the stack of 3 rings
        MoveForward(2.2, 6)
        wait(.3,SECONDS)
        TurnLeft(1.2,6)
        # To high goal
        wait(.3,SECONDS)
        MoveForward(.5,6)
        # ShootDisk(4, 12)
        # # Shoot
        # wait(.3,SECONDS)
        # RightFlywheel.spin(FORWARD)
        # LeftFlywheel.spin(FORWARD)
        # TurnRight(.85,7)
        # wait(.3, SECONDS)
        # # Back to stack of 3 disks
        # MoveForward(.6, 6, True)
        # wait(.3,SECONDS)
        # # Collect the 2 rings
        # MoveForward(.3,10, True)
        # ConveyorSpin(1)
        # ConveyorSpin(.5, 12, REVERSE)
        # MoveForward(.3,10, True)
        # ConveyorSpin(1)
        # # Turn Towards Goal
        # Left.spin_for(REVERSE, 365, DEGREES, wait=False)
        # Right.spin_for(FORWARD, 365, DEGREES)
        # # 135 degree rotation 
        # wait(.3,SECONDS)
        # ShootDisk(3)

    # When the robot needs a little help
    def RoboNotWorkFromRoller():
        # RightFlywheel.spin(FORWARD)
        # LeftFlywheel.spin(FORWARD)
        #270 degree rotation
        MoveForward(.3,7)
        ConveyorSpin(.7,9)
        wait(.3,SECONDS)
        # Rolling Motor
        MoveBack(.5, 7)
        wait(.3,SECONDS)
        # Move Back Slightly
        TurnLeft(2,6)
        wait(.3,SECONDS)
        # Turn towards the stack of 3 rings
        MoveForward(2.2, 6)
        wait(.3,SECONDS)
        TurnLeft(1.25,6)
        # To high goal
        wait(.3,SECONDS)
        MoveForward(.44,6)
        # ShootDisk(4, 12)
        # # Shoot
        # wait(.3,SECONDS)
        # RightFlywheel.spin(FORWARD)
        # LeftFlywheel.spin(FORWARD)
        # TurnRight(.85,7)
        # wait(.3, SECONDS)
        # # Back to stack of 3 disks
        # MoveForward(.6, 6, True)
        # wait(.3,SECONDS)
        # # Collect the 2 rings
        # MoveForward(.3,10, True)
        # ConveyorSpin(1)
        # ConveyorSpin(.5, 12, REVERSE)
        # MoveForward(.3,10, True)
        # ConveyorSpin(1)
        # # Turn Towards Goal
        # Left.spin_for(REVERSE, 365, DEGREES, wait=False)
        # Right.spin_for(FORWARD, 365, DEGREES)
        # # 135 degree rotation 
        # wait(.3,SECONDS)
        # ShootDisk(3)

    # This autonomous is for when we are on the side that doesnt allow us to be at the roller (2 preloads)

    # MAXIMUM PRIORITY (on code) but don't use
    def NotRoller():
        # RightFlywheel.spin(FORWARD)
        # LeftFlywheel.spin(FORWARD)
        MoveForward(1.2, 12, True)
        wait(.5,SECONDS)
        # Gather the 1 ring
        TurnRight(.9,12)
        wait(.3, SECONDS)
        MoveForward(1.5,12)
        # wait(.2,SECONDS)
        # MoveForward(.2, 12, True)
        # ConveyorSpin(1)
        # # Turn to the high goal
        # ShootDisk(5, 12)
        # # Shoot all the discs into it
        # TurnLeft(.6,12)
        # wait(.1,SECONDS)
        # # Turn to the left so that the robot faces the other rings
        # MoveForward(3,12,True)
        # wait(.1,SECONDS)
        # TurnRight(.5,12)
        # wait(.1,SECONDS)
        # ShootDisk(3)
        # # Gather rings, turn and shoot
        # TurnRight(.5,12)
        # wait(.1,SECONDS)
        # MoveForward(2)
        # wait(.1,SECONDS)
        # TurnLeft(.3,12)
        # wait(.1,SECONDS)
        # MoveForward(2,6,True)
        # # Go to the roller and spin it

    def NotRollerTowardRoller():
        MoveForward(2.1,6)
        wait(.3,SECONDS)
        TurnRight(1.48,6)
        wait(.3,SECONDS)
        MoveForward(1,6)
        wait(.3,SECONDS)
        ConveyorSpin(.25,12,REVERSE)

    #Start of Functions for Autonomous
    def MoveForward(timeF, WheelSpeed = 12, inp = False):
        Left.spin(FORWARD, WheelSpeed, VOLT)
        Right.spin(FORWARD, WheelSpeed, VOLT)

        if inp == True:
            Conveyor.spin(FORWARD, WheelSpeed, VOLT)
    
        wait(timeF, SECONDS)

        if inp == True:
            Conveyor.stop()

        Left.stop()
        Right.stop()


    def MoveBack(timeB, WheelSpeed = 12):
        Left.spin(REVERSE, WheelSpeed , VOLT)
        Right.spin(REVERSE, WheelSpeed, VOLT)
        wait(timeB, SECONDS)
        Left.stop()
        Right.stop()

    def TurnLeft(timeL, WheelSpeed = 12):
        Left.spin(REVERSE, WheelSpeed, VOLT)
        Right.spin(FORWARD, WheelSpeed, VOLT)
        wait(timeL, SECONDS)
        Left.stop()
        Right.stop()

    def TurnRight(timeR, WheelSpeed = 12):
        Left.spin(FORWARD, WheelSpeed, VOLT)
        Right.spin(REVERSE, WheelSpeed, VOLT)
        wait(timeR, SECONDS)
        Left.stop()
        Right.stop()

    def ConveyorSpin(timeV, ConveyorSpeed = 12, forr = FORWARD):
        Conveyor.spin(forr, ConveyorSpeed, VOLT)
        wait(timeV, SECONDS)
        Conveyor.stop()

    def FlywheelSpin(timeG, GS = 12):
        Flywheel.spin(FORWARD, GS, VOLT)
        wait(timeG, SECONDS)
        Flywheel.stop()

    def ShootDisk(timeD, AllSpeed = 12):
        Conveyor.spin(FORWARD, AllSpeed, VOLT)
        Flywheel.spin(FORWARD, AllSpeed, VOLT)
        wait(timeD, SECONDS)
        Conveyor.stop()
        Flywheel.stop()

    def OpticalChecker():
        while True:
            if optical.color == Color.RED:
                Conveyor.spin(FORWARD)
            if optical.color() == Color.BLUE:
                Conveyor.spin(REVERSE)

    def StringStart():
        StringMotor.spin(FORWARD)

    def StringEnd():
        StringMotor.stop()

    def RotateForward(sec, motors):
        for motor in motors:
            motor.spin(FORWARD)
        wait(sec, SECONDS)
        for motor in motors:
            motor.stop()

    def RotateReverse(sec, motors):
        for motor in motors:
            motor.spin(REVERSE)
        wait(sec, SECONDS)
        for motor in motors:
            motor.stop()

    # End of autonomous functions

    # Only have ONE of these uncommented

    wait(.3,SECONDS)

    # FromRoller()
    # RoboNotWorkFromRoller()
    # NotRoller()
    # NotRollerTowardRoller()
    OpticalChecker()

def user_control():
    pass

#create competition instance
comp = Competition(user_control, autonomous)
pre_autonomous()
